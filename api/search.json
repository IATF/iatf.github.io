[{"id":"d275443537d796e283f637e672cf7884","title":"python时间处理","content":"Python处理时间的几种方式1. 内置模块：time和datetime1.1 time官方地址：https://docs.python.org/zh-cn/3/library/time.html\n用的最多的几个方法time.time(),time.sleep(secs),time.strptime(string[, format])，可以用来获取当前时间戳，程序等待几秒，时间格式转换等，还有其他的一些方法，不做太多介绍，可以参考官方文档了解\nimport time\ntime.time()\n\n1706367977.4451728\n\n1.2 datetime官方地址：https://docs.python.org/zh-cn/3/library/datetime.html\n这个模块用的就非常多了，包括时间获取、格式转换、时间操作（相加、相减）、时区等等，日常经常使用，参见官方文档\n2. 第三方组件库这是额外补充的部分（第三方组件库用起来真的很爽）\n2.1 dateutil官方文档地址：https://dateutil.readthedocs.io/en/stable/\n如果你想要用来处理时间字符串转为时间格式的话，这个是真的很方便\n借用官方文档案例：\n&gt;&gt;&gt; from dateutil.parser import *\n&gt;&gt;&gt; from datetime import *\n&gt;&gt;&gt; now &#x3D; parse(&quot;2023-12-12 12:12:12&quot;)    # 这里提供时间格式字符串，直接帮你把时间字符串转为datetime时间格式\n\n对比下如果用官方内置datetime模块来处理的话，同样一个时间字符串\n\nfrom datetime import datetime\n\n_time &#x3D; datetime.strptime(&#39;2023-12-12 12:12:12&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)\nprint(_time)\n\ndatetime.datetime(2023, 12, 12, 12, 12, 12)\n\n对比一下，如果你需要提供一个通用的方法，用来做时间字符串转为时间格式，用datetime来实现的话，就需要提供format表达式，要不然无法正常解析时间，如果时间字符串一直是固定的，那可以默认使用，如果多样的时间格式，那就需要多种适配。\n这个时候直接引入第三方写好的，可以直接使用了。\n之前遇到一个坑的时间格式处理：日志中的时间格式全部都是这种2023-12-12T12:12:12.1234567Z,2023-12-12T12:12:12.12Z，最后的浮点数长度是不定的，从1位到7位不等，这个时候用format就不好用了\n按时间格式来写应该是这样的：%Y-%m-%dT%H:%M:%S.%fZ，浮点数用%f来标志，但是python的%f只能表示6位，这里最多到7位，就导致时间格式部分能解析成功，部分解析失败，此时直接用dateutil就不用考虑format的问题了\n时间格式代码：https://docs.python.org/zh-cn/3/library/datetime.html#strftime-and-strptime-behavior\n\n3. 其他开源时间相关的库3.1 农历(阴历)转换 LunarSolarConverter公历(阳历) 农历(阴历)转换，支持时间段从1900-2100 如果需要更长的时间段\npip install LunarSolarConverter\n\n3.2 工作日历 workalendarpip install workalendar\n\n3.3 中国法定节假日数据 holiday-cn中国法定节假日数据 自动每日抓取国务院公告\n","slug":"python时间处理","date":"2024-01-27T15:01:09.000Z","categories_index":"python","tags_index":"python经验","author_index":"小禅又小禅"},{"id":"edab951aaea45d7f19f050136703ffc3","title":"Python将网页保存为图片","content":"Python将网页保存为图片\n\n\n\n\n\n\n\n\n思路：通过selenium打开网页，然后将网页保存为图片\n\n\n\n\n\n\n\n\n\n依赖：chrome与chromedriver基础\n1. 首先官方下载chromedriverChromeDriver.com官方地址下载：https://chromedriver.com/\n需要注意与本地的chrome的版本一致，如果不确定本地版本可以在chrome的浏览器上进行查看\n2. 代码开发了from selenium import webdriver\nimport os\nimport time\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.chrome.service import Service\n\n\n# option参数设置，这里需要配置不需要打开浏览器，特别是如果想通过脚本运行或linux运行后台执行时\nchrome_options &#x3D; Options()\nchrome_options.add_argument(&#39;--headless&#39;)\nchrome_options.add_argument(&#39;--disable-gpu&#39;)\nchrome_options.add_argument(&#39;--start-maximized&#39;)\n\n# 配置本地下载的&#96;chromedriver&#96;地址\nservice &#x3D; Service(executable_path&#x3D;&#39;你得chromedriver的绝对路径&#39;)\ndriver &#x3D; webdriver.Chrome(options&#x3D;chrome_options, service&#x3D;service)\n\n# url是你要访问的地址\ndriver.get(url)\n# width和height\nwidth &#x3D; driver.execute_script(&quot;return Math.max(document.body.scrollWidth,document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);&quot;)\nheight &#x3D; driver.execute_script(&quot;return Math.max(document.body.scrollHeight, document.body.offsetHeight,document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);&quot;)\ndriver.set_window_size(width, height)\n# 这里设置一个等待时间，可以根据你的网页的请求状态来进行设置\ntime.sleep(1)\n# 保存图片\ndriver.save_screenshot(str(hash(url)) + &#39;.png&#39;)\n# 退出\ndriver.quit()\n\n\n3. docker服务运行docker下载：selenium/standalone-chrome:122.0\ndocker官方地址：https://hub.docker.com/r/selenium/standalone-chrome\n有了docker镜像，剩下的就是自己根据需求配置了\n","slug":"Python将网页保存为图片","date":"2023-08-19T07:13:54.000Z","categories_index":"python","tags_index":"python经验","author_index":"小禅又小禅"},{"id":"131b7583d9015ea1c037b717572010d5","title":"python将整个项目的py转为so","content":"将整python项目的代码中的py文件转为so\n\n\n\n\n\n\n\n\n[重要提醒]\n\n执行打包的动作，不要在源文件上进行，把代码复制到打包环境后再去打包分发，否则会因为清理代码的动作，造成代码丢失\n代码清理会清理&#39;.c&#39;, &#39;.py&#39;, &#39;.pyc&#39;, &#39;.o&#39;文件，所以如果项目中本身就有引用这些文件的话，则需要进行过滤忽略\n\n这里选用一个django项目：将django整个项目的代码全部转为so文件后，再发布\n1. 新建Django项目新建一个django项目：代码目录如下\n.\n├── account    # 新建的一个app\n│   ├── __init__.py\n│   ├── admin.py\n│   ├── apps.py\n│   ├── migrations\n│   │   └── __init__.py\n│   ├── models.py\n│   ├── tests.py\n│   └── views.py\n├── jiami\n│   ├── __init__.py\n│   ├── __pycache__\n│   │   ├── __init__.cpython-310.pyc\n│   │   └── settings.cpython-310.pyc\n│   ├── asgi.py\n│   ├── settings.py\n│   ├── urls.py\n│   └── wsgi.py\n└── manage.py\n\n\n现在把这个项目的所有py文件全部转成so，然后启动执行。\n先回忆下单个文件的做法：新建一个setup.py在guaner.py的同级目录下\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\nsetup(ext_modules&#x3D;cythonize([&quot;guaner.py&quot;]))\n示例：创建完成后目录结构如下\n.\n├── __init__.py\n├── guaner.py\n└── setup.py\n​\n0 directories, 3 files\n\n然后执行以下命令进行转so\npython setup.py build_ext\n生成的so文件如下\njiami\n├── build\n│   ├── lib.macosx-10.9-x86_64-3.10\n│   │   └── guaner.cpython-310-darwin.so\n│   └── temp.macosx-10.9-x86_64-3.10\n│       └── guaner.o\n├── guaner.c\n├── guaner.py\n└── setup.py\n\n2. 梳理要实现的效果同理我们要实现整个项目的py文件的so化后然后可以直接部署运行，需要做到以下几个要求：\n\n不能改变文件的目录结构\n原py文件不能存在，否则不能起到加密的用途\n不能产生非so的文件存在，如新生成的.c文件需要删除\n特殊文件不能转so，比如django的manage.py文件就不能转so，否则python manage.py xx命令无法执行\n\n3. 实现3.1 先实现转so的动作setup(ext_modules=cythonize([&quot;guaner.py&quot;]))中cythonize需要提供所有的py文件，那么要做的第一步就是获取所有的py文件\n3.1.1 获取项目中的所有py文件def get_all_py_files(dir_root):\n    &quot;&quot;&quot;获取所有的py文件，要编译成so的文件\n\n    :params dir_root: 项目根目录地址\n    &quot;&quot;&quot;\n    res_py_file_list &#x3D; []\n    for root, dirs, files in os.walk(dir_root):\n        for file in files:\n            if os.path.splitext(file)[1] !&#x3D; &#39;.py&#39;:\n                continue\n            if &#39;manage.py&#39; in file:\n                # manage.py文件需要排除在外，不能转so\n                continue\n            _path &#x3D; f&#39;&#123;root&#125;&#x2F;&#123;file&#125;&#39;\n            res_py_file_list.append(_path)\n    return res_py_file_list\n\n\n\n3.1.2 转so将生成的so文件全部生成在其py文件原来的目录下\n\ndef py_to_so():\n    project_dir &#x3D; &#39;.&#x2F;&#39;   # 项目相对路径\n    res_py_file_list &#x3D; get_all_py_files(project_dir)\n    build_dir &#x3D; &#39;.&#x2F;&#39;\n    build_tmp_dir &#x3D; &#39;.&#x2F;&#39;\n    # 为了让so文件直接在源目录结构下生成，所以指定buid和dist都是当前目录\n    setup(ext_modules&#x3D;cythonize(res_py_file_list), script_args&#x3D;[&quot;build_ext&quot;, &quot;-b&quot;, build_dir, &quot;-t&quot;, build_tmp_dir])\n\n\n\n执行转so，看看情况**完整的文件内容如下：jiami.py文件\n\nimport os\n\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\n\ndef get_all_py_files(dir_root):\n    &quot;&quot;&quot;获取所有的py文件，要编译成so的文件\n\n    :params dir_root: 项目根目录地址\n    &quot;&quot;&quot;\n    res_py_file_list &#x3D; []\n    for root, dirs, files in os.walk(dir_root):\n        for file in files:\n            if os.path.splitext(file)[1] !&#x3D; &#39;.py&#39;:\n                continue\n            if &#39;manage.py&#39; in file:\n                # manage.py文件需要排除在外，不能转so\n                continue\n            _path &#x3D; f&#39;&#123;root&#125;&#x2F;&#123;file&#125;&#39;\n            res_py_file_list.append(_path)\n    return res_py_file_list\n\n\ndef py_to_so():\n    project_dir &#x3D; &#39;.&#x2F;&#39;\n    res_py_file_list &#x3D; get_all_py_files(project_dir)\n    build_dir &#x3D; &#39;.&#x2F;&#39;\n    build_tmp_dir &#x3D; &#39;.&#x2F;&#39;\n\n    setup(ext_modules&#x3D;cythonize(res_py_file_list), script_args&#x3D;[&quot;build_ext&quot;, &quot;-b&quot;, build_dir, &quot;-t&quot;, build_tmp_dir])\n\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    py_to_so()\n\n\n执行python jiami.py开始转so，执行结束后，结果如下：\n.\n├── account\n│   ├── __init__.c\n│   ├── __init__.cpython-310-darwin.so\n│   ├── __init__.o\n│   ├── __init__.py\n│   ├── admin.c\n│   ├── admin.cpython-310-darwin.so\n│   ├── admin.o\n│   ├── admin.py\n│   ├── apps.c\n│   ├── apps.cpython-310-darwin.so\n│   ├── apps.o\n│   ├── apps.py\n│   ├── migrations\n│   │   ├── __init__.c\n│   │   ├── __init__.cpython-310-darwin.so\n│   │   ├── __init__.o\n│   │   └── __init__.py\n│   ├── models.c\n│   ├── models.cpython-310-darwin.so\n│   ├── models.o\n│   ├── models.py\n│   ├── tests.c\n│   ├── tests.cpython-310-darwin.so\n│   ├── tests.o\n│   ├── tests.py\n│   ├── views.c\n│   ├── views.cpython-310-darwin.so\n│   ├── views.o\n│   └── views.py\n├── jiami\n│   ├── __init__.c\n│   ├── __init__.cpython-310-darwin.so\n│   ├── __init__.o\n│   ├── __init__.py\n│   ├── __pycache__\n│   │   ├── __init__.cpython-310.pyc\n│   │   └── settings.cpython-310.pyc\n│   ├── asgi.c\n│   ├── asgi.cpython-310-darwin.so\n│   ├── asgi.o\n│   ├── asgi.py\n│   ├── settings.c\n│   ├── settings.cpython-310-darwin.so\n│   ├── settings.o\n│   ├── settings.py\n│   ├── urls.c\n│   ├── urls.cpython-310-darwin.so\n│   ├── urls.o\n│   ├── urls.py\n│   ├── wsgi.c\n│   ├── wsgi.cpython-310-darwin.so\n│   ├── wsgi.o\n│   └── wsgi.py\n├── jiami.c\n├── jiami.cpython-310-darwin.so\n├── jiami.o\n├── jiami.py\n└── manage.py\n\n可以看到Cython生成了一些.c、.o文件，以及我们想要的.so文件，当前我们满足了第一个要求**生成的so文件目录结构没有变化，下一步我们需要清理中间的.c、.o、.py文件。清理办法：遍历目录删除.c、.o、.py文件，剩下的都是想要的，只留下了so文件，以及可能存在的一些项目配置文件\n3.1.3 清理文件目录注意清理文件的时候需要注意，不能把没有转so的py文件也给清理了，否则可能会影响业务运行\n\ndef clean_c_file(dir_root):\n    for root, dirs, files in os.walk(dir_root):\n        for file in files:\n            # 这是执行的jiami.py文件，不需要转so，也不需要删除\n            if &#39;jiami.py&#39; in file:\n                continue\n            # 这是执行的django的命令入口文件，不需要转so，也不需要删除，否则会影响业务使用\n            if &#39;manage.py&#39; in file:\n                continue\n            if os.path.splitext(file)[1] in [&#39;.c&#39;, &#39;.py&#39;, &#39;.pyc&#39;, &#39;.o&#39;]:\n                _path &#x3D; f&#39;&#123;root&#125;&#x2F;&#123;file&#125;&#39;\n                os.remove(_path)\n\n\n然后我们再执行一次看看，先看完整的jiami.py文件内容\n这里有个危险的动作，清除掉多余的文件是直接删除了，所以执行前不要在源项目代码执行，而是在打包环境秩序，否则有可能会导致文件丢失\nimport os\n\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\n\ndef get_all_py_files(dir_root):\n    &quot;&quot;&quot;获取所有的py文件，要编译成so的文件\n\n    :params dir_root: 项目根目录地址\n    &quot;&quot;&quot;\n    res_py_file_list &#x3D; []\n    for root, dirs, files in os.walk(dir_root):\n        for file in files:\n            if os.path.splitext(file)[1] !&#x3D; &#39;.py&#39;:\n                continue\n            if &#39;manage.py&#39; in file:\n                # manage.py文件需要排除在外，不能转so\n                continue\n            _path &#x3D; f&#39;&#123;root&#125;&#x2F;&#123;file&#125;&#39;\n            res_py_file_list.append(_path)\n    return res_py_file_list\n\n\ndef clean_c_file(dir_root):\n    for root, dirs, files in os.walk(dir_root):\n        for file in files:\n            # 这是执行的jiami.py文件，不需要转so，也不需要删除\n            if &#39;jiami.py&#39; in file:\n                continue\n            # 这是执行的django的命令入口文件，不需要转so，也不需要删除，否则会影响业务使用\n            if &#39;manage.py&#39; in file:\n                continue\n            if os.path.splitext(file)[1] in [&#39;.c&#39;, &#39;.py&#39;, &#39;.pyc&#39;, &#39;.o&#39;]:\n                _path &#x3D; f&#39;&#123;root&#125;&#x2F;&#123;file&#125;&#39;\n                os.remove(_path)\n\n\ndef py_to_so():\n    project_dir &#x3D; &#39;.&#x2F;&#39;\n    res_py_file_list &#x3D; get_all_py_files(project_dir)\n    build_dir &#x3D; &#39;.&#x2F;&#39;\n    build_tmp_dir &#x3D; &#39;.&#x2F;&#39;\n\n    setup(ext_modules&#x3D;cythonize(res_py_file_list), script_args&#x3D;[&quot;build_ext&quot;, &quot;-b&quot;, build_dir, &quot;-t&quot;, build_tmp_dir])\n    # 清除文件\n    clean_c_file(project_dir)\n\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    py_to_so()\n\n\n\n\n执行python jiami.py开始转so，执行结束后，结果如下：\n.\n├── account\n│   ├── __init__.cpython-310-darwin.so\n│   ├── admin.cpython-310-darwin.so\n│   ├── apps.cpython-310-darwin.so\n│   ├── migrations\n│   │   └── __init__.cpython-310-darwin.so\n│   ├── models.cpython-310-darwin.so\n│   ├── tests.cpython-310-darwin.so\n│   └── views.cpython-310-darwin.so\n├── jiami\n│   ├── __init__.cpython-310-darwin.so\n│   ├── __pycache__\n│   ├── asgi.cpython-310-darwin.so\n│   ├── settings.cpython-310-darwin.so\n│   ├── urls.cpython-310-darwin.so\n│   └── wsgi.cpython-310-darwin.so\n├── jiami.cpython-310-darwin.so\n├── jiami.py\n└── manage.py\n\n\n不错，不错，是我想要的，除了so文件和我要留的外，项目代码很干净了，启动下看看，OK\nWatching for file changes with StatReloader\nPerforming system checks...\n\nSystem check identified no issues (0 silenced).\n\nYou have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.\nRun &#39;python manage.py migrate&#39; to apply them.\nAugust 19, 2023 - 10:16:20\nDjango version 4.2.1, using settings &#39;jiami.settings&#39;\nStarting development server at http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;\nQuit the server with CONTROL-C.\n\n\n4. 重点提醒\n\n\n\n\n\n\n\n\n[重要提醒]\n\n执行打包的动作，不要在源文件上进行，把代码复制到打包环境后再去打包分发，否则会因为清理代码的动作，造成代码丢失\n代码清理会清理&#39;.c&#39;, &#39;.py&#39;, &#39;.pyc&#39;, &#39;.o&#39;文件，所以如果项目中本身就有引用这些文件的话，则需要进行过滤忽略\n\n","slug":"python将整个项目的py转为so","date":"2023-08-19T07:13:54.000Z","categories_index":"python","tags_index":"加密","author_index":"小禅又小禅"},{"id":"ca7b5e095e51c6a96b8a0a9fffa545b0","title":"python生成验证码","content":"Python生成登录验证码现在很多web应用系统都要求增加验证码来防止暴力破解，增强应用系统的安全防护能力，验证码功能基本已成了一个应用系统的必要素之一\n如下图验证码：\n\n1.生成4个随机数\nfrom random import randint\n\ndef random_code(length):\n    charts &#x3D; [&#39;0&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;8&#39;,\n              &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;m&#39;, &#39;n&#39;, &#39;p&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;,\n              &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,\n              &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;J&#39;, &#39;K&#39;, &#39;M&#39;, &#39;N&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;,\n              &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]\n    chars &#x3D; &#39;&#39;\n    for i in range(length):\n        rd &#x3D; randint(0, len(charts) - 1)\n        chars +&#x3D; charts[rd]\n    return chars\n通过指定验证码长度来生成随机验证码数（某种程度保证了随机性）\n另外可以看到可以生成的随机数里面包括了数字、字母（大小写），也可以根据需要比如只要数字或者只要字母\n提醒： 如果是数字和字母混合的，最好剔除掉容易混淆的字符，比如1、l、i、I，0、O这些容易混淆的，毕竟大部分还是自己的用户在使用，用户体验也是一个很重要的部分\n2.生成图片有了验证码的字符后，那么下一步就是需要生成图片了，毕竟图片是需要在后端生成了返回给前端（ps：以前也遇到后端生成验证码，然后让前端渲染成图片的，这验证码可能只是为了满足有这个功能吧？）\n生成图片，推荐一个python第三方库captcha\n\nfrom captcha.image import ImageCaptcha\nchars &#x3D; random_code(4)     # 大部分验证码都是4位哈\nimage &#x3D; ImageCaptcha().generate_image(chars)\n\n\n3. 返回前端生成图片后，下一步要做的就是把图片返回给前端\n返回前端有多种方式，可以先把图片存储后，返回个url给前端，也可以把图片直接转base64返回前端，然后前端渲染，等等\n这里介绍一种把图片转base64的方式\nfrom io import BytesIO\nimport base64\n\nfile &#x3D; BytesIO()\n# 将图像保存在内存中\nimage.save(file, format&#x3D;&#39;png&#39;)   # 图片格式\n# 使用BytesIO().getvalue()转换为字节流\nbytes &#x3D; file.getvalue()\ndata &#x3D; base64.b64encode(bytes)\n\nreturn &#123;&#39;img&#39;: str(data, encoding&#x3D;&quot;utf-8&quot;)&#125;\n\n这样前端接收到img参数后，直接获取后渲染就可以了\n4. 后端处理有了验证码，也发送给前端了，那么我们还需要做的一件事情是，怎么验证\n后端验证的步骤：\n\n获取到验证码\n校验验证码有效性（验证两个：1.是不是我给你的，是不是你的；2.是否在有效期内）\n次数限制，验证码只允许验证一次，要不然还是可以暴力破解\n\n获取验证码好说，直接从post参数中提取就行了，那么怎么验证呢？\n\n是不是我给你的？是不是你的？这两个问题其实是一个意思：就是你提交给我的验证码，是不是我给你的。代表两个意思：1.是我颁发的；2.是我颁发，而且是给你的，不是你从别人那里拿来的\n\n\n\n\n\n\n\n\n\n\n\n一般做法是请求的时候生成的cookie里面携带的有request的标志参数，这个参数与验证码绑定了\n或者返回给你验证码的时候，再多给一个id，你提交的时候把id带上\n\n\n是否在有效期呢？验证码也是有有效期的，不是永久的， 一般会在5分钟内有效，也可以按要求调整，一般可以直接把验证码存在缓存里面，设置一个过期时间，就可以了\n\n不能多次验证验证码一旦提交验证后，不管成功还是失败，应该立即删除，从缓存中清除掉，保证不被重复使用\n\n\n# 这里只是一个例子，把验证码存入缓存中\ncache.set(str(key), value, timeout&#x3D;self.timeout)\n\n剩下的验证步骤就靠请求视图里面完善了，这是一个简单的验证码过程。\n","slug":"python生成验证码","date":"2024-01-30T13:58:56.000Z","categories_index":"python经验","tags_index":"安全,python经验","author_index":"小禅又小禅"},{"id":"b17cfe320b792f7a8a70851eed21c5c9","title":"python通过将py文件转为so实现代码加密","content":"这里介绍一种通过将 .py 代码转为.so文件来做到某种意义上的加密的方法\n前提提醒： 不同的操作系统环境中转so后只能在其相同的环境内执行，无法实现跨平台可用\n单个文件转so：把guaner.py文件转为so在guaner.py的同级目录下新建一个setup.py（名称可以自己定义，不一定要用setup.py命名）文件，文件的内容如下：\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\nsetup(ext_modules &#x3D; cythonize([&quot;guaner.py&quot;]))\n\n然后执行以下命令进行转so\npython setup.py build_ext\n\n示例：创建完成后目录结构如下\n.\n├── __init__.py\n├── guaner.py\n└── setup.py\n​\n0 directories, 3 files\n然后执行命令开始转so\n.\n├── __init__.py\n├── build\n│   ├── lib.macosx-10.9-x86_64-3.10\n│   │   └── test\n│   │       └── jiami\n│   │           └── guaner.cpython-310-darwin.so\n│   └── temp.macosx-10.9-x86_64-3.10\n│       └── guaner.o\n├── guaner.c\n├── guaner.py\n└── setup.py\n\n生成的so文件在build目录下，找到guaner.cpython-310-darwin.so就是转so后的文件了\n重点提醒： __init__.py文件对转so的影响\n注意看到，为什么多了一个jiami目录？首先看下我完整的文件目录结构：\ntest\n├── __init__.py\n├── jiami\n│   ├── guaner.py\n│   └── setup.py\n\n\n这是我完整的目录结构，里面有个很关键的文件，test目录下有__init__.py，jiami目录下也有__init__.py，在转so文件的时候，因为python代码结构中，如果目录中存在__init__.py，会把当前这个目录当作一个包，模块，可以被其他目录下代码引用，所以转so的时候，会顺着__init__.py所在的包结构，一层层的往上找，直到最后非python模块的目录为止\n因此打包完成后的目录结构就是这样的结构了：\n.\n├── __init__.py\n├── build\n│   ├── lib.macosx-10.9-x86_64-3.10\n│   │   └── test\n│   │       └── jiami\n│   │           └── guaner.cpython-310-darwin.so\n│   └── temp.macosx-10.9-x86_64-3.10\n│       └── guaner.o\n├── guaner.c\n├── guaner.py\n└── setup.py\n\n\n现在去掉__init__.py再打包看看结果jiami\n├── guaner.py\n└── setup.py\n\n执行python setup.py build_ext得到so文件目录如下\njiami\n├── build\n│   ├── lib.macosx-10.9-x86_64-3.10\n│   │   └── guaner.cpython-310-darwin.so\n│   └── temp.macosx-10.9-x86_64-3.10\n│       └── guaner.o\n├── guaner.c\n├── guaner.py\n└── setup.py\n\n这样看，代码是不是就很符合自己的期望了，这样把文件so文件分发到相同操作系统环境后，就可以放心执行不用担心别人可以查看我们的源代码了\n现在我们可以做到单个文件转位so了，那么我们是不是可以把当前的python项目整体的所有代码全部转位so文件了，这样发布给用户的时候，也不用担心看到我们的源代码了，下一章开始介绍打包整个python项目 \n","slug":"python通过将py文件转为so实现代码加密","date":"2023-08-18T16:21:34.000Z","categories_index":"python","tags_index":"加密","author_index":"小禅又小禅"},{"id":"eb5f4bc5c6b0be6986881b7a1cd7ad24","title":"小铲","content":"小铲\n","slug":"小铲","date":"2023-07-30T14:14:54.000Z","categories_index":"应用","tags_index":"密码本","author_index":"小禅又小禅"},{"id":"b545058e412a8c355d0fc0acd5583c4c","title":"应用下载","content":"应用下载1. 神兽密码本下载https://gitee.com/sunspace/shenshoumima/releases/tag/V1.3.2\n","slug":"应用下载","date":"2023-07-30T14:14:36.000Z","categories_index":"应用","tags_index":"密码本","author_index":"小禅又小禅"},{"id":"091d901a107acdab25635c2778679552","title":"安全产品大纲","content":"网络安全\n","slug":"安全产品大纲","date":"2023-07-30T12:59:51.000Z","categories_index":"安全","tags_index":"安全","author_index":"小禅又小禅"},{"id":"765c237e6edd8430fb074fe1ddc29da2","title":"小铲使用说明","content":"小铲子\n","slug":"小铲使用说明","date":"2023-07-30T12:52:51.000Z","categories_index":"应用","tags_index":"密码本","author_index":"小禅又小禅"},{"id":"6c5d4d98f2b1ebf7f008562a78831f62","title":"神兽密码本","content":"神兽密码本1. 下载安装在应用下载界面下载应用程序\n2. 设置主密码点击设置主密码 设置主密码\n输入主密码 这个密码是最重要的！！后续所有的账号认证都需要用到这个密码来进行验证，同时也是密码在本地存储加密的钥匙\n设置完密码后就可以开始使用啦\n3. 新增系统及账号3.1 新增系统\n3.2 新增标签新增标签输入需要的标签后，回车即可！\n给系统设置标签\n3.2 给系统新增账号添加账号密码也可以点击生成一个新的密码选择密码组成，密码长度，点击生成，可以生产一个符合自己需要的密码，如果需要使用，则点击应用按钮，刚生成的密码就可以被应用了，然后点击保存即可可以看到已生成的密码\n","slug":"神兽密码本","date":"2023-07-30T12:50:49.000Z","categories_index":"应用","tags_index":"密码本","author_index":"小禅又小禅"}]